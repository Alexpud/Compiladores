Helpers
	all = [0 .. 0xFFFF];
    	digit = ['0' .. '9'] ;
    	hex = [0..0x0fff];
    	caractere = ['a'..'z'] | ['A'..'Z'];
   	tab = 9;
	lf = 10;
	cr = 13;
   	apostrofo = ''';
   	aspas = '"';
   	not_eol = [all - [cr + lf]];
	eol = cr lf | cr | lf;
	sp = ' ';

States
	normal, comment;

Tokens
/* eol = fim de linha */

	//Lacos
	{normal}for 							= 'for';
	{normal}while 							= 'while';

	//Condicionais
	{normal}if 								= 'if' sp*;
	{normal}else 							= 'else';
	{normal}case 							= 'case' sp*;
	{normal}switch 							= 'switch';

	//Operadores e atribuicao
	{normal}op  		 					= ('+' | '-')sp*;
	{normal}multiplicacao 					= '*'  sp*;
	{normal}divisao  						=  '\' sp*;
	{normal}attr 							= '=' sp*;
	
	
	//Condicionais
	
	{normal}maior 							= '>' sp*;
	{normal}menor 							= '<' sp*;
	{normal}equal 							= '==' sp*;
	{normal}maior_igual 					= '>=' sp*;
	{normal}menor_igual 					= '<=' sp*;
	
	//Operacoes booleanas
	
	{normal}and								= '&&' sp*;
	{normal}or								= '|'  sp*;

	//Tipos
	{normal}array 							= 'array' sp*;
	{normal}int 							= 'int' sp*;
	{normal}char 							= 'char' sp*;
	{normal}float 							= 'float' sp*;

	//Tipos alguma coisa
	{normal}num_int 						= ('0x')?digit+ sp*;
	{normal}caractere_char 					= apostrofo caractere apostrofo sp*;
	{normal}float_number 					= digit+ '.'(digit+|'e'('+'|'-')digit+) sp*;



	//Pontuacao
	{normal}chave_e 						= '{';
	{normal}chave_d 						= '}';
	{normal}parenteses_e 					= '(';
	{normal}parenteses_d 					= ')';
	{normal}semi							= ';' lf?;
	{normal}comma 							= ',';
	{normal}dois_pontos						= ':' sp*;

	//Espaco

	//Comentario
	{normal->comment, comment} comment 		= '/*';
	{comment->normal} comment_end 			= '*/';
	{comment} comment_body 					= [all - ['*' + '/']]*;
	{comment} asteristico 							= '*';
	{comment} barra 						= '/';
	{normal} line_comment 					= '//'[all - 10]*10*;
	sp = ' ' sp*;

	{normal}begin 							= 'begin';
	{normal}end 							= 'end';
	{normal}return 							= 'return' sp*;
	{normal}void 							= 'void';
	{normal}new 							= 'new';

	{normal} blank 							= (eol | tab | ' ')+;

	//identificador
	{normal}identificador 					= caractere (caractere|digit)* sp*;

/*Funcionou desse jeito
	program 								= begin variables end semi;
	variables 								=  int semi ;
	*/

	/*Boiolagem de erro quando coloco da forma {coma identificador}
	  O erro e o seguinte:org.sablecc.sablecc.parser.ParserException: [86,32] expecting: '->'
		Para contornar esse problema, olhei a documentaÃ§Ã£o do sablecc, e vi que para as producoes para
		terem opcoes, voce tem que identificar essas opcoes com { identificacao }. Pagina 45 da tese do sablecc.
*/

Ignored Tokens
	blank, comment, comment_end, comment_body, line_comment;

Productions

	programa     = declaracao*;

	declaracao   = tipo identificador decl | 
				   {atribuicao}attr_var;
	
	/*Fiz uma pequena fatoracao a esquerda, havia dois tipos de declaracoes onde mudavam apenas o final,
	 logo fatorei como tinha na prova, para tirar ambiguidade e ficar mais bonito.
	*/
	
	decl = {variavel}semi | {funcao}parametros body;

	tipo 	     = {inteiro} int |
			       {charizard} char | 
			       {floatomon} float;

	parametros   = parenteses_e parametros_variaveis* parenteses_d;
	
	parametros_variaveis	 = 	tipo identificador comma|
					{more10one}tipo identificador;

	body 	     = 	chave_e bloco;
	
	bloco        =	declaracao bloco|
					{opt2}identificador parametros bloco|
					{opt3}condicional bloco|
					{opt4}return identificador semi chave_d|
					{opt5}laco bloco|
					{opt6}chave_d;
					
					
	attr_var     =	identificador attr operacao semi|
					{opt2}tipo identificador attr valores semi;					
    
    	operacao 	 =	valores operadores operacao|
    				{valor}valores;
	
	operadores	= 	op|
					{mul}multiplicacao|
					{div}divisao;
	
	valores      =  num_int|
					{chari}caractere_char|
					{floato}float_number|
					{iden}identificador;
	
	se = if parenteses_e condicao parenteses_d chave_e bloco;
	
	se_nao = {vazio} | {senao} else chave_e bloco ;
	
	condicional  = 	se se_nao|
					{switches} avalie;

	//condicional  = 	if parenteses_e condicao parenteses_d chave_e bloco;
	
	avalie = switch parenteses_e valores parenteses_d chave_e case caso;
	
	caso = valores dois_pontos bloco_switch;
	
	bloco_switch = 	case caso|
					{opt1}declaracao bloco_switch|
					{opt2}identificador parametros bloco_switch|
					{opt3}condicional bloco_switch|
					{opt4}return identificador semi bloco_switch|
					{opt5}laco bloco_switch|
					{opt6}chave_d semi;
					
	condicao	 =	identificador|
					{condicao2}identificador sinais valores|
					{condicao3}identificador sinais valores expressoes;
					
	expressoes 		= and |{ou} or;
	
	sinais 	 	= 	  maior| 
					  {op2}menor | 
					  {op3}equal;
	
	laco = lacos_operadores parenteses_e condicao parenteses_d  chave_e bloco;
	
	lacos_operadores =  for|
						{opt2}while;
	
	
	/*

	Tomar cuidado com os conflitos shift-reduce e reduce reduce, peguei 1 quando tentei fazer dois tipos de parametros, um para declaração de funcão
	e outro para chamada de função.Ele executa normal, mas quando chega na criação de arvores ou do DFA da erro.
	*/
