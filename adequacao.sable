Helpers
	all = [0 .. 0xFFFF];
    	digit = ['0' .. '9'] ;
    	hex = [0..0x0fff];
    	caractere = ['a'..'z'] | ['A'..'Z'];
   	tab = 9;
	lf = 10;
	cr = 13;
   	apostrofo = ''';
   	aspas = '"';
   	not_eol = [all - [cr + lf]];
	eol = cr lf | cr | lf;
	sp = ' ';

States
	normal, comment;

Tokens
/* eol = fim de linha */

	//Lacos
	{normal}for 							= 'for';
	{normal}foreach							= 'for each';
	{normal}while 							= 'while';

	//Condicionais
	{normal}if 								= 'if' sp*;
	{normal}else 							= 'else';
	{normal}case 							= 'case' sp*;
	{normal}switch 							= 'switch';

	//Operadores e atribuicao
	{normal}op  		 					= ('+' | '-')sp*;
	{normal}multiplicacao 					= '*'  sp*;
	{normal}divisao  						=  '\' sp*;
	{normal}attr 							= '=' sp*;
	{normal}incremento						= '++';
	{normal}decremento						= '--';
	
	
	//Condicionais
	
	{normal}maior 							= '>' sp*;
	{normal}menor 							= '<' sp*;
	{normal}equal 							= '==' sp*;
	{normal}maior_igual 					= '>=' sp*;
	{normal}menor_igual 					= '<=' sp*;
	
	//Operacoes booleanas
	
	{normal}and								= '&&' sp*;
	{normal}or								= '|'  sp*;

	//Tipos
	{normal}array 							= 'array' sp*;
	{normal}int 							= 'int' sp*;
	{normal}char 							= 'char' sp*;
	{normal}float 							= 'float' sp*;

	//Tipos alguma coisa
	{normal}num_int 						= ('0x')?digit+ sp*;
	{normal}caractere_char 					= apostrofo caractere apostrofo sp*;
	{normal}float_number 					= digit+ '.'(digit+|'e'('+'|'-')digit+) sp*;



	//Pontuacao
	{normal}chave_e 						= '{';
	{normal}chave_d 						= '}';
	{normal}parenteses_e 					= '(';
	{normal}parenteses_d 					= ')';
	{normal}semi							= ';' lf?;
	{normal}virgula 							= ',';
	{normal}dois_pontos						= ':' sp*;

	//Espaco

	//Comentario
	{normal->comment, comment} comment 		= '/*';
	{comment->normal} comment_end 			= '*/';
	{comment} comment_corpo 					= [all - ['*' + '/']]*;
	{comment} asteristico 							= '*';
	{comment} barra 						= '/';
	{normal} line_comment 					= '//'[all - 10]*10*;
	sp = ' ' sp*;

	{normal}begin 							= 'begin';
	{normal}end 							= 'end';
	{normal}return 							= 'return' sp*;
	{normal}void 							= 'void';
	{normal}new 							= 'new';

	{normal} blank 							= (eol | tab | ' ')+;

	//identificador
	{normal}identificador 					= caractere (caractere|digit)* sp*;

/*Funcionou desse jeito
	program 								= begin variables end semi;
	variables 								=  int semi ;
	*/

	/*Boiolagem de erro quando coloco da forma {coma identificador}
	  O erro e o seguinte:org.sablecc.sablecc.parser.ParserException: [86,32] expecting: '->'
		Para contornar esse problema, olhei a documentação do sablecc, e vi que para as producoes para
		terem opcoes, voce tem que identificar essas opcoes com { identificacao }. Pagina 45 da tese do sablecc.
*/

Ignored Tokens
	blank, comment, comment_end, comment_corpo, line_comment;

Productions
	//Existe a questao da criacao de listas.
	programa{->programa}							= 	declaracoes{-> New programa ([declaracoes.declaracao])};
	
	declaracoes{->declaracao*} 						=	declaracao*{->[declaracao.declaracao]};
	
	declaracao{->declaracao}						= 	declaracao_variavel{-> New declaracao(declaracao_variavel)}|
														{funcao}declaracao_funcao{-> New declaracao.funcao(declaracao_funcao)};
	
	declaracao_variavel{->declaracao_variavel}		= 	tipo identificador semi {-> New declaracao_variavel(tipo.tipo , identificador )}|
														{atribuicao} identificador attr valores semi{-> New declaracao_variavel.atribuicao(identificador,valores.valores)}|
														{criacao_atribuicao}tipo identificador attr valores semi{->New declaracao_variavel.criacao_atribuicao(tipo,identificador,valores.valores)};
	
	declaracao_funcao{->declaracao_funcao}			=	tipo identificador parenteses_e parametros parenteses_d{-> New declaracao_funcao(tipo,identificador,[parametros.parametros_variaveis])};
	
	tipo{->tipo}									= 	tipo_base{-> tipo_base.tipo}|
														{void}void{-> New tipo.void(void)};
	
	tipo_base{->tipo} 								=	{inteiro} int {-> New tipo.inteiro(int)}|
														{flutuante}float {->New tipo.flutuante(float)}|
														{caractere} char {->New tipo.caractere(char)};
	
	valores{->valores}      						=  	tipo_base_valores{->tipo_base_valores.valores};
					
	tipo_base_valores{->valores}					= 	{numerointeiro}num_int{->    New valores.numerointeiro(num_int)}|
														{caractere}caractere_char{-> New valores.caractere(caractere_char)}|
														{numerofloat}float_number{->New valores.numerofloat(float_number)};
									
	parametros{->parametros_variaveis*}				=	parametros_variaveis*{->[parametros_variaveis.parametros_variaveis]};
	
	parametros_variaveis{->parametros_variaveis} 	=	{varios}virgula{->New parametros_variaveis.varios(virgula)}|
														{unico}tipo identificador{->New parametros_variaveis.unico(tipo,identificador)};
					
Abstract Syntax Tree
	
	programa 										=	declaracao*;
	
	declaracao 										=	declaracao_variavel|
														{funcao}declaracao_funcao;
	declaracao_variavel 							=	[a]:tipo [asd]:identificador|
														{atribuicao}identificador valores|
														{criacao_atribuicao}tipo identificador valores;
	
	valores											=	{numerointeiro}num_int|
														{caractere}caractere_char|
														{numerofloat}float_number;
	
	declaracao_funcao								=	tipo identificador parametros_variaveis*;
	
	parametros_variaveis							=	{unico}tipo identificador|
														{varios}virgula;
	
	tipo 											= 	{inteiro} int|
														{flutuante}float|
														{void}void|
														{caractere} char;
					